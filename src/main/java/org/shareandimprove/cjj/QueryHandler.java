package org.shareandimprove.cjj;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

/**
 * A utility class for validating parts of a SQL query.
 * This class provides methods to check if a string is a valid SQLite column name or a number.
 */
class Validator { // generated by Gemini 2.5 Pro
    private static final Set<String> SQLITE_KEYWORDS = new HashSet<>(Arrays.asList(
            "ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND",
            "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY",
            "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "COMMIT", "CONFLICT",
            "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME",
            "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE",
            "DESC", "DETACH", "DISTINCT", "DO", "DROP", "EACH", "ELSE", "END", "ESCAPE",
            "EXCEPT", "EXCLUDE", "EXCLUSIVE", "EXISTS", "EXPLAIN", "FAIL", "FILTER",
            "FIRST", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL", "GENERATED", "GLOB",
            "GROUP", "GROUPS", "HAVING", "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX",
            "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO",
            "IS", "ISNULL", "JOIN", "KEY", "LAST", "LEFT", "LIKE", "LIMIT", "MATCH",
            "NATURAL", "NO", "NOT", "NOTHING", "NOTNULL", "NULL", "NULLS", "OF", "OFFSET",
            "ON", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARTITION", "PLAN",
            "PRAGMA", "PRECEDING", "PRIMARY", "QUERY", "RAISE", "RANGE", "RECURSIVE",
            "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME", "REPLACE",
            "RESTRICT", "RIGHT", "ROLLBACK", "ROW", "ROWS", "SAVEPOINT", "SELECT",
            "SET", "TABLE", "TEMP", "TEMPORARY", "THEN", "TIES", "TO", "TRANSACTION",
            "TRIGGER", "UNBOUNDED", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM",
            "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT"
    ));

    private static final Pattern UNQUOTED_COLUMN_NAME_PATTERN = Pattern.compile("^[a-zA-Z_][a-zA-Z0-9_]*$");

    /**
     * Checks if a string is a valid unquoted column name for SQLite.
     *
     * @param columnName 要验证的列名字符串
     * @return 如果合法则返回 true，否则返回 false
     */
    public static boolean isValidAttr(String columnName) {
        // 1. 检查null或空字符串
        if (columnName == null || columnName.trim().isEmpty()) {
            return false;
        }

        // 2. 检查是否为带引号的标识符
        // 允许 "column-name", [column-name], `column-name`
        // 只要被正确引用，内部内容几乎可以是任何东西，且长度必须大于2
        // Commented because it's risky
        /*
        if (columnName.length() > 2) {
            char firstChar = columnName.charAt(0);
            char lastChar = columnName.charAt(columnName.length() - 1);
            if ((firstChar == '"' && lastChar == '"') ||
                (firstChar == '[' && lastChar == ']') ||
                (firstChar == '`' && lastChar == '`')) {
                return true; // 带引号的标识符总是合法的（只要不为空）
            }
        }
        */

        // 3. 检查是否为不带引号的标识符
        // 3.1. 检查字符是否合法 (不能以数字开头，只能包含字母数字和下划线)
        if (!UNQUOTED_COLUMN_NAME_PATTERN.matcher(columnName).matches()) {
            return false;
        }

        // 3.2. 检查是否为SQLite关键字 (不区分大小写)
        if (SQLITE_KEYWORDS.contains(columnName.toUpperCase())) {
            return false; // 不带引号的标识符不能是关键字
        }

        // 4. 如果通过所有检查，则是合法的不带引号的列名
        return true;
    }

    /**
     * Checks if a string represents a valid integer.
     * @param str The string to check.
     * @return {@code true} if the string is an integer, {@code false} otherwise.
     */
    public static boolean isInteger(String str){
        if(str==null){
            return false;
        }
        int length = str.length();
        for(int i=0;i<length;++i){
            char c = str.charAt(i);
            if((c<'0'||c>'9') && c!='-'){
                return false;
            }
        }
        return true;
    }

    /**
     * Checks if a string represents a valid floating-point number.
     * @param str The string to check.
     * @return {@code true} if the string is a float, {@code false} otherwise.
     */
    public static boolean isFloat(String str){
        if(str==null){
            return false;
        }
        int length = str.length();
        for(int i=0;i<length;++i){
            char c = str.charAt(i);
            if(c<'-' || c>'9' || c=='/'){//`-./0123456789`
                return false;
            }
        }
        return true;
    }
}


/**
 * A simple container class for a pair of strings.
 */
class StringPair{
    private String former;
    private String latter;

    /**
     * Constructs a StringPair.
     * @param former The first string.
     * @param latter The second string.
     */
    StringPair(String former, String latter){
        this.former = former;
        this.latter = latter;
    }

    /**
     * @return The first string in the pair.
     */
    public String getFormer(){
        return this.former;
    }

    /**
     * @return The second string in the pair.
     */
    public String getLatter(){
        return this.latter;
    }
}

/**
 * An extension of {@link ArrayList} of {@link String} with helper methods for safe access.
 */
class StringList extends ArrayList<String>{
    /**
     * Safely gets an element at a given index.
     * @param index The index of the element.
     * @return The element at the specified index, or {@code null} if the index is out of bounds.
     */
    public String safeGet(int index){
        if(index<0 || index >= this.size()){
            return null;
        }else{
            return super.get(index);
        }
    }
    @Override
    /**
     * @return A single string with all elements joined by a space.
     */
    public String toString(){
        return String.join(" ", this);
    }

    /**
     * Safely gets the last element of the list.
     * @return The last element, or {@code null} if the list is empty.
     */
    public String safeGetLast(){
        int size = this.size();
        if(size==0){
            return null;
        }
        return this.get(size-1);
    }
}

/**
 * Handles the conversion of a custom query syntax into a SQL WHERE clause.
 * This class is responsible for parsing a user-provided search string and translating it into a valid SQL condition.
 */
public class QueryHandler{

    /**
     * Parses a statement in the custom query language into a SQL conditional expression.
     * @param statement The custom query string to parse.
     * @return A SQL WHERE clause fragment.
     * @throws IllegalArgumentException if the statement has syntax errors.
     */
    private static String parseStatement(String statement) throws IllegalArgumentException{

        
        if(statement.length() == 0){
            throw new IllegalArgumentException("Cannot parse an empty search string");
        }

        /* code below tokenizes the input statement */
        StringBuilder token = new StringBuilder();
        StringList stringList = new StringList();
        StringPair stringPair;
        int i=0;
        while(i<statement.length()){
            if(statement.startsWith("..", i)){
                if(token.length()>0){
                    stringList.add(token.toString());
                    token.setLength(0);
                }
                stringList.add("..");
                i+=2;//"..".length();
                continue;
            }
            if(token.length()==0){
                if(statement.startsWith("NOT", i)){
                    stringList.add("NOT");
                    i+=3;//"NOT".length();
                    continue;
                }
                if(statement.startsWith("AND", i)){
                    stringList.add("AND");
                    i+=3;//"AND".length();
                    continue;
                }
                if(statement.startsWith("OR", i)){
                    stringList.add("OR");
                    i+=2;//"OR".length();
                    continue;
                }
            }
            switch(statement.charAt(i)){
                case '(':
                    if(token.length()>0){
                        stringList.add(token.toString());
                        token.setLength(0);
                    }
                    if(":".equals(stringList.safeGetLast())){
                        throw new IllegalArgumentException("Bracket after a colon `:(` is not yet supported. ");
                    }
                    stringPair = parseBracket(statement.substring(i));
                    stringList.add(stringPair.getFormer());
                    statement = stringPair.getLatter();
                    i=0;
                    break;
                case ')':
                    throw new IllegalArgumentException("Extra closing bracket");
                case '"':
                    if(token.length()>0){
                        stringList.add(token.toString());
                        token.setLength(0);
                    }
                    stringPair = parseQuote(statement.substring(i));
                    stringList.add(stringPair.getFormer());
                    statement = stringPair.getLatter();
                    i=0;
                    break;
                case ':':
                    if(token.length()>0){
                        stringList.add(token.toString());
                        token.setLength(0);
                    }
                    stringList.add(":");
                    ++i;
                    break;
                case ' ':
                    if(token.length()>0){
                        stringList.add(token.toString());
                        token.setLength(0);
                    }
                    ++i;
                    break;
                case '*':
                    token.append('%'); //sqlite wildcard for any length (including 0) of any character
                    ++i;
                    break;
                case '?':
                    token.append('_'); //sqlite wildcard for a single character
                    ++i;
                    break;
                case '_':
                case '%':
                case '\\':
                    token.append('\\');
                default:
                    token.append(statement.charAt(i));
                    ++i;
            }
        }
        if(token.length()>0){
            stringList.add(token.toString());
        }

        
        /* code below merges tokens `colname`, `:`, `"someValue"` into a single token: `colname="someValue"` */
        /* also, `..` will be parsed */
        /* meanwhile, NOT is merged into its subsequent slice */
        /* Note that `:` has a higher priority than `NOT``AND``OR`, meaning that `attr:AND` will be parsed as `attr LIKE "%AND%"`*/

        for(i=stringList.size()-1;i>=0;--i){
            String currToken = stringList.get(i);
            String prevToken = stringList.safeGet(i-1);
            if(":".equals(prevToken)){ // prevToken.equals(":") will throw an error if safeGet returns null
                String attrName = stringList.safeGet(i-2);
                if(!Validator.isValidAttr(attrName)){
                    throw new IllegalArgumentException("`"+attrName+"` is not a valid attribute name");
                }
                if(Config.getDateAttrNames().contains(attrName.toLowerCase())){ // the attribute should be a date
                    stringList.set(i, parseDate(currToken));
                    stringList.set(i-1, "=");
                }else if(Config.getNumAttrNames().contains(attrName.toLowerCase())){ // the attribute should be a number
                    if(!Validator.isFloat(currToken)){
                        throw new IllegalArgumentException("`"+currToken+"` is not a number");
                    }
                    stringList.set(i-1, "=");
                }else{ // the attribute should be a number
                    if(currToken.startsWith("\"")){// starting with quotation mark, meaning exact match
                        stringList.set(i-1, "=");
                    }else{// fuzzy match
                        stringList.set(i-1, "LIKE");
                        stringList.set(i, "\"%"+currToken+"%\" ESCAPE '\\'");
                    }
                }
                String condition = String.join(" ", stringList.subList(i-2, i+1));
                i -= 2;
                stringList.set(i, condition);
                stringList.subList(i+1, i+3).clear();
            }else if("..".equals(prevToken)){ // parsing `..`
                String lowerBound = stringList.safeGet(i-2);
                // String upperBound = currToken;
                if(!Validator.isFloat(lowerBound) || !Validator.isFloat(currToken)){
                    throw new IllegalArgumentException("Illegal use of notation `..`, which should be placed between two numbers");
                }
                if(":".equals(stringList.safeGet(i-3))){
                    String attrName = stringList.safeGet(i-4);
                    if(!Validator.isValidAttr(attrName)){
                        throw new IllegalArgumentException("`"+attrName+"` is not a valid attribute name");
                    }
                    if(Config.getDateAttrNames().contains(attrName.toLowerCase())){
                        lowerBound = parseDate(lowerBound);
                        currToken = parseDate(currToken);
                    }else if(!Config.getNumAttrNames().contains(attrName.toLowerCase())){
                        throw new IllegalArgumentException("`"+attrName+"` is nut a numeric attribute name");
                    }
                    i -= 4;
                    stringList.set(i, "("+attrName+" >= "+lowerBound+" AND "+attrName+" < "+currToken+")");
                    stringList.subList(i+1, i+5).clear();
                    continue;
                }// else: `filename > lowerBound`, which is currently not supported
                throw new IllegalArgumentException("Attribute name for range (represented by notation `..`) is not specified");
            }else if(
                currToken.charAt(0) == '('
                  ||
                currToken.equals("AND")
                  ||
                currToken.equals("OR")
            ){ // omit logic predicates
                continue;
            }else if(currToken.equals("NOT")){
                if(stringList.safeGet(i+1) == null){
                    throw new IllegalArgumentException("Predicate `NOT` found at the end of syntax");
                }
                stringList.set(i, "NOT "+stringList.get(i+1));
                stringList.remove(i+1);
            }else{ // unmarked string, taken as search term for `filename`
                if(stringList.get(i).startsWith("\"")){// starting with quotation mark, meaning exact match
                    stringList.set(i, "filename = "+stringList.get(i));
                }else{// fuzzy match
                    stringList.set(i, "filename LIKE \"%"+stringList.get(i)+"%\" ESCAPE '\\'");
                }
            }
        }

        
        /* code below finalizes the logic by ensuring AND, OR are used correctly */

        // check whether AND, OR exist at either end
        if(
            stringList.get(0).equals("AND")
              ||
            stringList.get(0).equals("OR")
              ||
            stringList.safeGetLast().equals("AND")
              ||
            stringList.safeGetLast().equals("OR")
        ){
            throw new IllegalArgumentException("`AND` or `OR` found at either end of the syntax");
        }
                // iterate to check whether each `AND`/`OR` are placed between 
        boolean isPrevPredicate = false;
        boolean isCurrPredicate;
        for(i=1;i<stringList.size();++i){ // Note that the stringList.size() could change during iteration
            isCurrPredicate = (stringList.get(i).equals("AND")||stringList.get(i).equals("OR"));
            if(isPrevPredicate){
                if(isCurrPredicate){
                    throw new IllegalArgumentException("Two consecutive predicates found during parsing");
                }
            }else{
                if(!isCurrPredicate){ // consecutive condition statements, connecting with `AND`
                    stringList.add(i, "AND");
                    ++i;
                    isPrevPredicate = false;
                    continue;
                }
            }
            isPrevPredicate = isCurrPredicate;
        }
                return stringList.toString();
    }
    private static StringPair parseBracket(String statement) throws IllegalArgumentException{
        /**
         * Parses a substring enclosed in parentheses.
         * @param statement The string starting with '('.
         * @return A {@link StringPair} containing the parsed parenthesized expression and the rest of the statement.
         * @throws IllegalArgumentException if brackets are mismatched.
         */
                int i, balance = 0;
        for(i=0;i<statement.length();++i){
            switch(statement.charAt(i)){
                case '(':
                    ++balance;
                    break;
                case ')':
                    --balance;
                    break;
            }
            if(balance==0){
                return new StringPair("("+parseStatement(statement.substring(1, i))+")", statement.substring(i+1));
            }
        }
        throw new IllegalArgumentException((balance>0?"Missing":"Extra") + " closing bracket");
    }
    private static StringPair parseQuote(String quoteString) throws IllegalArgumentException{
        /**
         * Parses a substring enclosed in double quotes.
         * @param quoteString The string starting with '"'.
         * @return A {@link StringPair} containing the quoted string and the rest of the statement.
         * @throws IllegalArgumentException if the closing quote is missing.
         */
                int i;
        for(i=1;i<quoteString.length()&&quoteString.charAt(i)!='"';++i);

        if(i==quoteString.length()){
            throw new IllegalArgumentException("Missing closing quotation mark");
        }
        return new StringPair(quoteString.substring(0, i+1), quoteString.substring(i+1));
    }

    /**
     * Parses a date string (e.g., "2024", "0315", "20240315") into a Unix timestamp string.
     * @param dateString The date string to parse.
     * @return A string representing the Unix timestamp (in seconds).
     * @throws IllegalArgumentException if the date format is invalid.
     */
    public static String parseDate(String dateString) throws IllegalArgumentException{
                switch(dateString.length()){
            case 4:
            case 6:
            case 8:
                break;
            default:
                throw new IllegalArgumentException("`"+dateString+"`: Illegal date format");
        }
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
        
        sdf.setTimeZone(TimeZone.getTimeZone("GMT+8"));
        String currDateString = sdf.format(new Date());
        dateString = currDateString.substring(0, 8-dateString.length()) + dateString;

        try {
            return String.valueOf(sdf.parse(dateString).getTime()/1000);
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }

    /**
     * Converts a high-level query string into a full SQL SELECT statement.
     * @param query The user-provided query string.
     * @return A complete SQL SELECT statement.
     * @throws IllegalArgumentException if the query is invalid.
     */
    public static String query2SQL(String query) throws IllegalArgumentException{
        Log.println(query);
        return "SELECT " + Config.getSelectColumns() + " FROM FILE WHERE " + parseStatement(query.trim()) + " ORDER BY filename, filetype DESC;";
    }

    /**
     * Main method for internal testing of the query parser.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args){ // test cases
        System.out.println(query2SQL("default treatment filetype:\"pdf\" AND ((filename:\"world\") OR filename: hello) AND filesize:12 .. 1234 AND time:19700101..20250101 OR time:1023"));
        //System.out.println(query2SQL("[filename];\nDROP\nTABLE\nFILE;\n--]:1"));
        System.out.println(query2SQL("file:\"0;\n DROP TABLE FILE; --\""));
    }
}